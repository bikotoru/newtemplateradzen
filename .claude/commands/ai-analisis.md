# Sistema de An√°lisis y Generaci√≥n de Prompts por Etapas

## Variables
- **SOLICITUD_USUARIO**: $ARGUMENTS (descripci√≥n en lenguaje natural)
- **RAIZ_PROYECTO**: Directorio actual de trabajo
- **ANALISIS_DIR**: ./analisis/ (directorio de an√°lisis generados)

## üéØ Prop√≥sito
Sistema inteligente que analiza solicitudes complejas del usuario y las divide en etapas manejables, generando prompts espec√≠ficos para cada fase que pueden ser ejecutados secuencialmente con @ai-plan.

## üö® REGLAS CR√çTICAS

### 1. Gesti√≥n de Archivos de An√°lisis
```yaml
ESTRUCTURA_OBLIGATORIA:
  analisis/
  ‚îú‚îÄ‚îÄ {timestamp}_{nombre_solicitud}/
  ‚îÇ   ‚îú‚îÄ‚îÄ analisis.md              # An√°lisis completo de la solicitud
  ‚îÇ   ‚îú‚îÄ‚îÄ etapa1_prompt.md         # Prompt para etapa 1
  ‚îÇ   ‚îú‚îÄ‚îÄ etapa2_prompt.md         # Prompt para etapa 2  
  ‚îÇ   ‚îú‚îÄ‚îÄ etapa3_prompt.md         # Prompt para etapa N
  ‚îÇ   ‚îú‚îÄ‚îÄ secuencia.md             # Orden de ejecuci√≥n
  ‚îÇ   ‚îî‚îÄ‚îÄ validaciones.md          # Checkpoints entre etapas

NAMING_CONVENTION:
  timestamp: YYYYMMDD_HHMMSS
  nombre_solicitud: snake_case_descriptivo
```

### 2. Principios de Divisi√≥n por Etapas
```yaml
CRITERIOS_DIVISION:
  ETAPA_1_BASE: [entidades_independientes, configuraciones_basicas]
  ETAPA_2_RELACIONES: [entidades_con_fk, lookups_simples] 
  ETAPA_3_TRANSACCIONAL: [procesos_negocio, validaciones_complejas]
  ETAPA_4_INTEGRACION: [reportes, exportacion, apis_externas]
  ETAPA_5_OPTIMIZACION: [performance, ui_avanzada, dashboards]

MAXIMAS_POR_ETAPA:
  - Max 4 entidades por etapa
  - Max 2 m√≥dulos nuevos por etapa
  - Max 1 funcionalidad compleja por etapa
  - Cada etapa debe ser completamente funcional
```

### 3. Detecci√≥n de Complejidad
```yaml
INDICADORES_COMPLEJIDAD_ALTA:
  palabras_clave: [sistema, plataforma, completo, integral, avanzado]
  cantidad_entidades: >5
  multiples_modulos: >2
  integraciones: [api, reportes, notificaciones, workflows]
  
ESTRATEGIAS_SIMPLIFICACION:
  horizontal: dividir por m√≥dulos funcionales
  vertical: dividir por capas (datos ‚Üí l√≥gica ‚Üí ui)
  temporal: dividir por fases de desarrollo (mvp ‚Üí features ‚Üí optimizaci√≥n)
```

## üîç FASE 0: AN√ÅLISIS DE COMPLEJIDAD

### Detector de Complejidad
```python
def analizar_complejidad_solicitud(solicitud_usuario):
    """
    Analiza la complejidad y determina estrategia de divisi√≥n
    """
    
    indicadores = {
        "entidades_detectadas": extraer_entidades(solicitud_usuario),
        "modulos_implicados": detectar_modulos(solicitud_usuario),
        "integraciones": detectar_integraciones(solicitud_usuario),
        "procesos_complejos": detectar_procesos(solicitud_usuario)
    }
    
    nivel_complejidad = calcular_nivel_complejidad(indicadores)
    
    if nivel_complejidad == "BAJA":
        return {"etapas": 1, "estrategia": "DIRECTA"}
    elif nivel_complejidad == "MEDIA":
        return {"etapas": 2-3, "estrategia": "POR_DEPENDENCIAS"}
    else:  # ALTA
        return {"etapas": 3-5, "estrategia": "POR_FUNCIONALIDAD"}

def extraer_entidades(solicitud):
    """Detecta entidades mencionadas expl√≠cita o impl√≠citamente"""
    
    # Patrones expl√≠citos
    entidades_explicitas = re.findall(r'\b([A-Z][a-z]+(?:[A-Z][a-z]+)*)\b', solicitud)
    
    # Patrones impl√≠citos por dominio
    patrones_negocio = {
        "ventas": ["cliente", "producto", "categoria", "venta", "factura"],
        "inventario": ["producto", "categoria", "almacen", "movimiento", "proveedor"],
        "rrhh": ["empleado", "cargo", "departamento", "contrato", "nomina"],
        "crm": ["cliente", "contacto", "empresa", "oportunidad", "seguimiento"],
        "escolar": ["estudiante", "curso", "profesor", "materia", "calificacion"],
        "medico": ["paciente", "doctor", "cita", "diagnostico", "tratamiento"],
        "logistico": ["vehiculo", "ruta", "conductor", "envio", "tracking"]
    }
    
    entidades_implicitas = []
    for dominio, entidades in patrones_negocio.items():
        if dominio in solicitud.lower():
            entidades_implicitas.extend(entidades)
    
    return list(set(entidades_explicitas + entidades_implicitas))

def detectar_integraciones(solicitud):
    """Detecta integraciones y funcionalidades complejas"""
    
    integraciones = []
    
    patrones_integracion = {
        "reportes": ["reporte", "excel", "pdf", "dashboard", "grafico"],
        "notificaciones": ["email", "sms", "notificacion", "alerta"],
        "apis": ["api", "servicio", "integracion", "webhook"],
        "workflow": ["aprobacion", "flujo", "workflow", "proceso"],
        "facturacion": ["factura", "boleta", "tributario", "sunat"],
        "pagos": ["pago", "tarjeta", "banco", "transferencia"],
        "auditoria": ["log", "auditoria", "seguimiento", "trazabilidad"]
    }
    
    for categoria, palabras in patrones_integracion.items():
        if any(palabra in solicitud.lower() for palabra in palabras):
            integraciones.append(categoria)
    
    return integraciones
```

## üèóÔ∏è FASE 1: GENERACI√ìN DE ETAPAS

### Estrategias de Divisi√≥n
```python
def generar_etapas_por_estrategia(entidades, integraciones, estrategia):
    """
    Genera etapas seg√∫n la estrategia detectada
    """
    
    if estrategia == "POR_DEPENDENCIAS":
        return dividir_por_dependencias(entidades)
    elif estrategia == "POR_FUNCIONALIDAD":  
        return dividir_por_funcionalidad(entidades, integraciones)
    else:  # DIRECTA
        return [{"etapa": 1, "entidades": entidades, "descripcion": "Implementaci√≥n completa"}]

def dividir_por_dependencias(entidades):
    """Divisi√≥n basada en dependencias entre entidades"""
    
    # Construir grafo de dependencias
    grafo = construir_grafo_dependencias(entidades)
    niveles = ordenar_por_niveles(grafo)
    
    etapas = []
    for i, nivel in enumerate(niveles):
        etapas.append({
            "etapa": i + 1,
            "entidades": nivel,
            "descripcion": f"Entidades de nivel {i + 1}",
            "justificacion": "Basado en dependencias de foreign keys"
        })
    
    return etapas

def dividir_por_funcionalidad(entidades, integraciones):
    """Divisi√≥n por funcionalidades de negocio"""
    
    etapas = [
        {
            "etapa": 1,
            "titulo": "Base de Datos y Entidades Core",
            "entidades": filtrar_entidades_core(entidades),
            "descripcion": "Crear entidades base y estructura fundamental",
            "incluye": ["tablas", "permisos", "crud_basico"]
        },
        {
            "etapa": 2, 
            "titulo": "L√≥gica de Negocio y Relaciones",
            "entidades": filtrar_entidades_relacionales(entidades),
            "descripcion": "Implementar relaciones y validaciones complejas",
            "incluye": ["foreign_keys", "validaciones", "lookups"]
        },
        {
            "etapa": 3,
            "titulo": "Procesos Transaccionales", 
            "entidades": filtrar_entidades_transaccionales(entidades),
            "descripcion": "Crear procesos de negocio y workflows",
            "incluye": ["transacciones", "workflows", "calculos"]
        }
    ]
    
    # Agregar etapas de integraci√≥n si se detectaron
    if integraciones:
        etapas.append({
            "etapa": 4,
            "titulo": "Integraciones y Reportes",
            "entidades": [],
            "descripcion": "Implementar integraciones externas y reporter√≠a",
            "incluye": integraciones
        })
    
    return etapas
```

### Generador de Prompts por Etapa
```python
def generar_prompt_para_etapa(etapa_info, contexto_solicitud):
    """
    Genera prompt espec√≠fico y detallado para una etapa
    """
    
    prompt_base = f"""
# ETAPA {etapa_info['etapa']}: {etapa_info['titulo']}

## Contexto Original
{contexto_solicitud['solicitud_original']}

## Objetivo de Esta Etapa
{etapa_info['descripcion']}

## Entidades a Implementar en Esta Etapa
{generar_lista_entidades_detallada(etapa_info['entidades'])}

## Restricciones Espec√≠ficas
- SOLO implementar las entidades listadas arriba
- NO crear dependencias hacia entidades de etapas futuras
- Usar campos string temporales para relaciones futuras si es necesario
- Validar compilaci√≥n exitosa antes de continuar

## Validaciones Post-Implementaci√≥n
{generar_checklist_validacion(etapa_info)}

## Preparaci√≥n para Siguiente Etapa
{generar_notas_siguiente_etapa(etapa_info)}
"""
    
    return prompt_base

def generar_lista_entidades_detallada(entidades):
    """Genera descripci√≥n detallada de entidades para la etapa"""
    
    descripcion = ""
    for entidad in entidades:
        descripcion += f"""
### {entidad['nombre']}
- **M√≥dulo**: {entidad['modulo']}
- **Campos sugeridos**: {', '.join(entidad['campos'])}
- **Relaciones**: {entidad['relaciones'] if entidad['relaciones'] else 'Ninguna en esta etapa'}
- **Justificaci√≥n**: {entidad['justificacion']}
"""
    
    return descripcion
```

## üìã TEMPLATES DE PROMPTS GENERADOS

### Template para Etapa Base
```markdown
# ETAPA 1: Entidades Base y Configuraci√≥n

## Objetivo
Crear la estructura fundamental del sistema con entidades independientes que no tienen dependencias externas.

## Implementar:
- Categoria (Cat√°logo)
- Cliente (Ventas) 
- TipoDocumento (Admin.Config)

## Prompt para @ai-plan:
```
crear las siguientes entidades base:

1. Categoria en m√≥dulo Catalogo.Core con campos: nombre (string 100), descripcion (text), activo (bool)
2. Cliente en m√≥dulo Ventas.Core con campos: razon_social (string 200), ruc (string 20), telefono (string 15), email (string 100) 
3. TipoDocumento en m√≥dulo Admin.Config con campos: nombre (string 50), codigo (string 10), descripcion (text)

Configurar formularios con validaciones b√°sicas y grillas de listado est√°ndar.
```

## Validaciones Post-Etapa:
- [ ] 3 tablas creadas correctamente
- [ ] Compilaci√≥n exitosa: dotnet build
- [ ] Interfaces CRUD funcionando
- [ ] 18 permisos creados (6 por entidad)

## Notas para Etapa 2:
La siguiente etapa podr√° referenciar estas entidades mediante foreign keys.
```

### Template para Etapa Relacional
```markdown
# ETAPA 2: Entidades con Relaciones

## Prerequisitos:
‚úÖ Etapa 1 completada exitosamente
‚úÖ Entidades base: Categoria, Cliente disponibles

## Implementar:
- Producto (‚Üí Categoria)
- Proveedor (Cat√°logo)
- ContactoCliente (‚Üí Cliente)

## Prompt para @ai-plan:
```
crear las siguientes entidades con relaciones:

1. Producto en m√≥dulo Catalogo.Core con campos: nombre (string 255), codigo (string 50), precio (decimal 18,2), stock_minimo (int) y relaci√≥n con categoria_id mediante lookup
2. Proveedor en m√≥dulo Catalogo.Core con campos: razon_social (string 200), ruc (string 20), telefono (string 15), email (string 100)
3. ContactoCliente en m√≥dulo Ventas.Core con campos: nombre (string 100), telefono (string 15), email (string 100), cargo (string 50) y relaci√≥n con cliente_id

Configurar lookups funcionales en formularios y grillas con nombres descriptivos.
```

## Validaciones Post-Etapa:
- [ ] Foreign keys funcionando correctamente  
- [ ] Lookups mostrando nombres en lugar de IDs
- [ ] Validaci√≥n de integridad referencial
- [ ] Compilaci√≥n y funcionamiento correcto
```

## üîÑ FLUJO DE EJECUCI√ìN COMPLETO

### Comando del Usuario
```bash
@ai-analisis "crear un sistema completo de gesti√≥n escolar con estudiantes, profesores, cursos, materias, calificaciones, horarios, reportes acad√©micos y dashboard administrativo"
```

### Procesamiento Autom√°tico
```markdown
üîç AN√ÅLISIS DE COMPLEJIDAD (15 segundos):
‚îú‚îÄ‚îÄ üìä Entidades detectadas: 8 (estudiante, profesor, curso, materia, calificacion, horario, reporte, dashboard)
‚îú‚îÄ‚îÄ üèóÔ∏è M√≥dulos implicados: 3 (Academico, Admin, Reportes)
‚îú‚îÄ‚îÄ üîß Integraciones: reportes, dashboard
‚îú‚îÄ‚îÄ üìà Nivel complejidad: ALTA
‚îú‚îÄ‚îÄ üéØ Estrategia: POR_FUNCIONALIDAD  
‚îî‚îÄ‚îÄ üìã Etapas sugeridas: 4

üèóÔ∏è GENERACI√ìN DE ETAPAS (30 segundos):
‚îú‚îÄ‚îÄ üìÅ Crear: analisis/20240306_143530_sistema_escolar/
‚îú‚îÄ‚îÄ üìù Generar an√°lisis completo
‚îú‚îÄ‚îÄ üéØ Crear 4 prompts espec√≠ficos
‚îú‚îÄ‚îÄ üìã Definir secuencia de ejecuci√≥n
‚îî‚îÄ‚îÄ ‚úÖ Validaciones entre etapas

üìä RESULTADO:
‚Ä¢ 4 etapas planificadas
‚Ä¢ Prompts espec√≠ficos listos
‚Ä¢ Secuencia de ejecuci√≥n definida
‚Ä¢ Checkpoints de validaci√≥n
‚Ä¢ Estimaci√≥n: 2-3 d√≠as de desarrollo
```

### Archivos Generados
```
analisis/20240306_143530_sistema_escolar/
‚îú‚îÄ‚îÄ analisis.md              # "Detect√© 8 entidades, 3 m√≥dulos, complejidad ALTA"
‚îú‚îÄ‚îÄ etapa1_prompt.md         # "crear estudiante, profesor, materia (entidades base)"  
‚îú‚îÄ‚îÄ etapa2_prompt.md         # "crear curso, horario con relaciones a etapa 1"
‚îú‚îÄ‚îÄ etapa3_prompt.md         # "crear calificacion, sistema de notas"
‚îú‚îÄ‚îÄ etapa4_prompt.md         # "crear reportes acad√©micos y dashboard"
‚îú‚îÄ‚îÄ secuencia.md             # Orden exacto de ejecuci√≥n
‚îî‚îÄ‚îÄ validaciones.md          # Checkpoints entre cada etapa
```

## üéØ EJEMPLOS DE USO

### Solicitud Simple ‚Üí 1 Etapa
**Input:** `"crear producto y categoria"`
**Output:** 1 prompt directo para @ai-plan

### Solicitud Media ‚Üí 2-3 Etapas  
**Input:** `"sistema de ventas b√°sico"`
**Output:** Etapa 1: entidades base, Etapa 2: relaciones, Etapa 3: procesos

### Solicitud Compleja ‚Üí 4-5 Etapas
**Input:** `"plataforma e-commerce completa"`
**Output:** Etapa 1: cat√°logo, Etapa 2: usuarios, Etapa 3: ventas, Etapa 4: pagos, Etapa 5: reportes

## üîß CARACTER√çSTICAS INTELIGENTES

### An√°lisis Contextual
- **Detecta dominios**: "escolar" ‚Üí infiere entidades acad√©micas
- **Reconoce patrones**: "completo/integral" ‚Üí divide en m√°s etapas
- **Identifica dependencias**: orden autom√°tico de implementaci√≥n

### Generaci√≥n de Prompts Inteligente
- **Espec√≠ficos por etapa**: solo entidades correspondientes
- **Restricciones claras**: evita dependencias futuras  
- **Validaciones incluidas**: checkpoints autom√°ticos
- **Preparaci√≥n siguiente etapa**: notas para continuidad

### Control de Complejidad
- **M√°ximo 4 entidades por etapa**
- **Etapas completamente funcionales**
- **Validaci√≥n entre etapas**
- **Rollback si falla una etapa**

El sistema convierte solicitudes complejas ambiciosas en planes de implementaci√≥n estructurados y manejables, eliminando la par√°lisis por an√°lisis y garantizando progreso constante.