# Componente Lookup - Guía Completa

## Descripción General

El componente `Lookup` es un selector avanzado basado en `RadzenDropDownDataGrid` que proporciona funcionalidades de búsqueda, filtrado, cache inteligente y creación rápida de elementos. Está diseñado para ser fuertemente tipado y altamente configurable.

## Características Principales

- ✅ **Búsqueda fuertemente tipada** con campos específicos
- ✅ **Cache inteligente** con TTL configurable  
- ✅ **Filtrado en memoria** para performance óptima
- ✅ **Creación rápida** de elementos con modal
- ✅ **QueryBuilder integration** para filtros base
- ✅ **OnLoad personalizado** para lógica avanzada
- ✅ **Auto-invalidación** de cache al crear elementos

## Parámetros Principales

### Parámetros Básicos
```csharp
[Parameter] public TValue Value { get; set; }                    // Valor seleccionado
[Parameter] public EventCallback<TValue> ValueChanged { get; set; } // Evento de cambio
[Parameter] public BaseApiService<TEntity> Service { get; set; } // Servicio de datos
[Parameter] public string DisplayProperty { get; set; } = "Nombre"; // Propiedad a mostrar
[Parameter] public string ValueProperty { get; set; } = "Id";    // Propiedad del valor
[Parameter] public string Placeholder { get; set; } = "Seleccionar..."; // Placeholder
```

### Parámetros de Cache (NUEVO)
```csharp
[Parameter] public bool EnableCache { get; set; } = false;       // Habilitar cache
[Parameter] public TimeSpan? CacheTTL { get; set; } = TimeSpan.FromMinutes(5); // Tiempo de vida
[Parameter] public string? CacheKey { get; set; }                // Clave personalizada
```

### Parámetros de Búsqueda (NUEVO)
```csharp
[Parameter] public Expression<Func<TEntity, object>>[]? SearchableFields { get; set; } // Campos buscables
[Parameter] public bool ShowSearch { get; set; } = true;         // Mostrar búsqueda
```

### Parámetros de Creación
```csharp
[Parameter] public bool ShowAdd { get; set; } = true;            // Mostrar botón +
[Parameter] public EventCallback Add { get; set; }               // Callback personalizado
[Parameter] public Type? FastCreateComponentType { get; set; }   // Componente para crear
[Parameter] public string EntityDisplayName { get; set; } = "elemento"; // Nombre para UI
```

### Parámetros Avanzados
```csharp
[Parameter] public QueryBuilder<TEntity>? BaseQuery { get; set; } // Filtro base
[Parameter] public RenderFragment? ColumnsTemplate { get; set; }  // Template de columnas
[Parameter] public string ModalWidth { get; set; } = "400px";     // Ancho del modal
[Parameter] public string ModalHeight { get; set; } = "600px";    // Alto del modal
[Parameter] public Func<LoadDataArgs, QueryBuilder<TEntity>?, Task<ApiResponse<PagedResult<TEntity>>>>? OnLoad { get; set; } // Carga personalizada
```

## Uso Básico

### Ejemplo Simple
```razor
<Lookup TEntity="Categoria" 
       TValue="Guid?" 
       @bind-Value="categoriaId"
       Service="CategoriaService"
       EntityDisplayName="Categoría" />
```

### Ejemplo con Cache y Campos Buscables
```razor
@* En el .razor.cs *@
private Expression<Func<Categoria, object>>[] categoriaSearchFields = 
    SearchFields<Categoria>(c => c.Nombre, c => c.Descripcion);

@* En el .razor *@
<Lookup TEntity="Categoria" 
       TValue="Guid?" 
       @bind-Value="categoriaId"
       Service="CategoriaService"
       SearchableFields="@categoriaSearchFields"
       EnableCache="true"
       CacheTTL="TimeSpan.FromMinutes(10)"
       CacheKey="categorias_activas"
       EntityDisplayName="Categoría" />
```

## Configuraciones de Cache

### Cache para Datos Estáticos (Recomendado)
```razor
@* Catálogos que cambian poco - TTL largo *@
<Lookup TEntity="Pais" 
       EnableCache="true"
       CacheTTL="TimeSpan.FromHours(2)"
       CacheKey="paises_activos" />
```

### Cache para Datos Semi-Dinámicos
```razor
@* Datos que cambian ocasionalmente - TTL mediano *@
<Lookup TEntity="Usuario" 
       EnableCache="true"
       CacheTTL="TimeSpan.FromMinutes(5)"
       CacheKey="usuarios_activos" />
```

### Sin Cache para Datos Dinámicos
```razor
@* Datos que cambian frecuentemente - Sin cache *@
<Lookup TEntity="Pedido" 
       EnableCache="false" />
```

## Campos Buscables Fuertemente Tipados

### Helper Method (Recomendado)
```csharp
// En tu componente .cs
private static Expression<Func<T, object>>[] SearchFields<T>(params Expression<Func<T, object>>[] fields)
{
    return fields;
}

// Configurar campos específicos
private Expression<Func<Categoria, object>>[] categoriaFields = 
    SearchFields<Categoria>(c => c.Nombre, c => c.Descripcion);

private Expression<Func<Usuario, object>>[] usuarioFields = 
    SearchFields<Usuario>(u => u.Nombre, u => u.Email, u => u.Telefono);
```

### Uso en el Lookup
```razor
<Lookup SearchableFields="@categoriaFields" />  @* Solo busca en Nombre y Descripción *@
<Lookup SearchableFields="@usuarioFields" />    @* Busca en Nombre, Email y Teléfono *@
<Lookup />                                       @* Busca en todas las propiedades string *@
```

## QueryBuilder Integration

### Filtros Base
```csharp
// En OnInitialized()
var baseFilter = CategoriaService.Query()
    .Where(c => c.Activo == true)
    .Where(c => c.Nombre.StartsWith("A"));

// Combinaciones
var otherFilter = CategoriaService.Query().Where(c => c.Descripcion != null);
var combined = baseFilter.And(otherFilter);  // A + Descripción no null
var alternative = baseFilter.Or(otherFilter); // A OR Descripción no null
```

```razor
<Lookup BaseQuery="@baseFilter" />       @* Solo categorías activas que empiecen con A *@
<Lookup BaseQuery="@combined" />         @* Filtro combinado con AND *@
<Lookup BaseQuery="@alternative" />      @* Filtro combinado con OR *@
```

## OnLoad Personalizado

### Ejemplo con Logging y Transformaciones
```csharp
private Func<LoadDataArgs, QueryBuilder<Categoria>?, Task<ApiResponse<PagedResult<Categoria>>>>? customOnLoad;

protected override void OnInitialized()
{
    customOnLoad = async (args, query) =>
    {
        // Logging personalizado
        Console.WriteLine($"Cargando datos: Skip={args.Skip}, Top={args.Top}, Filter={args.Filter}");
        
        // Lógica de carga con query combinado
        var result = query != null 
            ? await CategoriaService.LoadDataAsync(args, query)
            : await CategoriaService.LoadDataAsync(args);
        
        // Transformaciones post-carga
        if (result.Success && result.Data?.Data != null)
        {
            foreach (var item in result.Data.Data)
            {
                // Ejemplo: agregar prefijo a nombres
                if (!item.Nombre.StartsWith("[CACHE]"))
                    item.Nombre = $"[CACHE] {item.Nombre}";
            }
        }
        
        return result;
    };
}
```

```razor
<Lookup OnLoad="@customOnLoad" />
```

## Creación Rápida de Elementos

### Con Componente Fast
```csharp
// Fast.razor debe devolver la entidad creada
public partial class Fast : ComponentBase
{
    [Parameter] public EventCallback<Categoria> OnSave { get; set; }
    
    private async Task Save()
    {
        // ... lógica de guardado ...
        if (response.Success && response.Data != null)
        {
            await DialogService.CloseAsync(response.Data); // ← Devolver la entidad
        }
    }
}
```

```razor
<Lookup FastCreateComponentType="typeof(Fast)"
       ModalWidth="500px"
       ModalHeight="400px" />
```

### Con Callback Personalizado
```csharp
private async Task HandleAddCategoria()
{
    // Tu lógica personalizada para crear
    var nuevaCategoria = await MiLogicaPersonalizada();
    
    // El Lookup se actualizará automáticamente
}
```

```razor
<Lookup Add="@HandleAddCategoria" 
       ShowAdd="true" />
```

## Ejemplos Completos

### Lookup Básico sin Cache
```razor
<RadzenFormField Text="Usuario Asignado">
    <Lookup TEntity="Usuario" 
           TValue="Guid?" 
           @bind-Value="usuarioId"
           Service="UsuarioService"
           DisplayProperty="NombreCompleto"
           EntityDisplayName="Usuario"
           ShowAdd="false" />
</RadzenFormField>
```

### Lookup con Cache y Búsqueda Específica
```razor
@* En .razor.cs *@
private Expression<Func<Cliente, object>>[] clienteFields = 
    SearchFields<Cliente>(c => c.RazonSocial, c => c.CUIT, c => c.Email);

@* En .razor *@
<RadzenFormField Text="Cliente">
    <Lookup TEntity="Cliente" 
           TValue="Guid?" 
           @bind-Value="clienteId"
           Service="ClienteService"
           SearchableFields="@clienteFields"
           EnableCache="true"
           CacheTTL="TimeSpan.FromMinutes(15)"
           CacheKey="clientes_activos"
           EntityDisplayName="Cliente"
           FastCreateComponentType="typeof(ClienteFast)"
           ModalWidth="800px"
           ModalHeight="600px" />
</RadzenFormField>
```

### Lookup con Filtro Base y OnLoad
```csharp
// En .razor.cs
private QueryBuilder<Producto>? productosActivos;
private Expression<Func<Producto, object>>[] productoFields = 
    SearchFields<Producto>(p => p.Nombre, p => p.Codigo, p => p.Categoria.Nombre);

private Func<LoadDataArgs, QueryBuilder<Producto>?, Task<ApiResponse<PagedResult<Producto>>>>? onLoadProductos;

protected override void OnInitialized()
{
    // Filtro base: solo productos activos
    productosActivos = ProductoService.Query()
        .Where(p => p.Activo == true)
        .Where(p => p.Stock > 0);
    
    // OnLoad personalizado con logging
    onLoadProductos = async (args, query) =>
    {
        Logger.LogInformation($"Cargando productos - Filtro: {args.Filter}");
        
        var result = await ProductoService.LoadDataAsync(args, query);
        
        // Agregar información de stock en tiempo real
        if (result.Success && result.Data?.Data != null)
        {
            foreach (var producto in result.Data.Data)
            {
                var stockActual = await StockService.GetStockActualAsync(producto.Id);
                producto.StockActual = stockActual;
            }
        }
        
        return result;
    };
}
```

```razor
<RadzenFormField Text="Producto">
    <Lookup TEntity="Producto" 
           TValue="Guid?" 
           @bind-Value="productoId"
           Service="ProductoService"
           BaseQuery="@productosActivos"
           SearchableFields="@productoFields"
           OnLoad="@onLoadProductos"
           EnableCache="true"
           CacheTTL="TimeSpan.FromMinutes(2)"
           EntityDisplayName="Producto">
        
        <ColumnsTemplate>
            <RadzenDropDownDataGridColumn Property="Codigo" Title="Código" Width="100px" />
            <RadzenDropDownDataGridColumn Property="Nombre" Title="Nombre" Width="200px" />
            <RadzenDropDownDataGridColumn Property="Stock" Title="Stock" Width="80px" />
        </ColumnsTemplate>
        
    </Lookup>
</RadzenFormField>
```

## Mejores Prácticas

### ✅ Cuándo Usar Cache
- **Catálogos estáticos**: Países, estados, categorías (TTL: 1-2 horas)
- **Datos de referencia**: Usuarios, clientes, proveedores (TTL: 5-15 minutos)
- **Configuraciones**: Parámetros del sistema (TTL: 30-60 minutos)

### ❌ Cuándo NO Usar Cache
- **Datos transaccionales**: Pedidos, facturas, movimientos
- **Datos en tiempo real**: Stock en vivo, precios dinámicos
- **Datos personales**: Información del usuario actual

### 🎯 Campos Buscables
```csharp
// ✅ BUENO - Campos relevantes para el usuario
SearchFields<Cliente>(c => c.RazonSocial, c => c.CUIT, c => c.Email)

// ❌ MALO - Demasiados campos irrelevantes  
SearchFields<Cliente>(c => c.Id, c => c.FechaCreacion, c => c.UsuarioCreacion)

// ✅ BUENO - Sin especificar = busca en todas las string properties
// No especificar SearchableFields para entidades simples
```

### 🔑 Cache Keys
```csharp
// ✅ BUENO - Descriptivas y únicas
CacheKey="categorias_activas_departamento_ventas"
CacheKey="usuarios_habilitados_sucursal_central"

// ❌ MALO - Genéricas o confusas
CacheKey="data"
CacheKey="lookup1"
```

## Invalidación de Cache

### Automática
El cache se invalida automáticamente cuando:
- Se crea un nuevo elemento desde el Lookup
- Se usa el callback `Add` personalizado

### Manual
```csharp
// Desde código
lookupRef.InvalidateCache();

// Desde servicios después de operaciones CRUD
CacheService.RemoveByPattern("categorias_*");
```

## Troubleshooting

### Performance
- **Problema**: Lookup lento en primera carga
- **Solución**: Habilitar cache con `EnableCache="true"`

### Búsqueda
- **Problema**: No encuentra elementos que deberían existir  
- **Solución**: Verificar `SearchableFields` - asegurar que incluye los campos correctos

### Cache
- **Problema**: Datos desactualizados en el Lookup
- **Solución**: Reducir `CacheTTL` o invalidar manualmente

### Memory
- **Problema**: Uso excesivo de memoria
- **Solución**: Usar cache solo para datasets pequeños (&lt;10,000 registros)

## Ejemplos de Configuración por Escenario

### 1. Catálogo de Países (Datos Estáticos)
```csharp
private Expression<Func<Pais, object>>[] paisFields = 
    SearchFields<Pais>(p => p.Nombre, p => p.Codigo);
```
```razor
<Lookup TEntity="Pais" 
       SearchableFields="@paisFields"
       EnableCache="true"
       CacheTTL="TimeSpan.FromHours(24)"
       CacheKey="paises_todos"
       ShowAdd="false" />
```

### 2. Selector de Clientes (Datos Semi-Dinámicos)
```csharp
private QueryBuilder<Cliente>? clientesActivos = 
    ClienteService.Query().Where(c => c.Activo == true);

private Expression<Func<Cliente, object>>[] clienteFields = 
    SearchFields<Cliente>(c => c.RazonSocial, c => c.CUIT, c => c.Email);
```
```razor
<Lookup TEntity="Cliente" 
       BaseQuery="@clientesActivos"
       SearchableFields="@clienteFields"
       EnableCache="true"
       CacheTTL="TimeSpan.FromMinutes(10)"
       FastCreateComponentType="typeof(ClienteFast)"
       ModalWidth="800px" />
```

### 3. Selector de Productos (Con Stock en Tiempo Real)
```csharp
private Func<LoadDataArgs, QueryBuilder<Producto>?, Task<ApiResponse<PagedResult<Producto>>>>? onLoadProductos;

protected override void OnInitialized()
{
    onLoadProductos = async (args, query) =>
    {
        var result = await ProductoService.LoadDataAsync(args, query);
        
        // Enriquecer con información de stock en tiempo real
        if (result.Success && result.Data?.Data != null)
        {
            foreach (var producto in result.Data.Data)
            {
                producto.StockDisponible = await StockService.GetDisponibleAsync(producto.Id);
            }
        }
        
        return result;
    };
}
```
```razor
<Lookup TEntity="Producto" 
       OnLoad="@onLoadProductos"
       EnableCache="false"  @* Sin cache por datos dinámicos *@
       SearchableFields="@SearchFields<Producto>(p => p.Nombre, p => p.Codigo)" />
```

## Integración con QueryBuilder

### Filtros Complejos
```csharp
// Filtros base complejos
var filtroAvanzado = CategoriaService.Query()
    .Where(c => c.Activo == true)
    .Where(c => c.FechaCreacion >= DateTime.Now.AddMonths(-6))
    .Where(c => c.Departamento == "Ventas");

// Combinar con otros filtros
var filtroAdicional = CategoriaService.Query()
    .Where(c => c.Prioridad == "Alta");

var filtroFinal = filtroAvanzado.And(filtroAdicional);
```

### Uso con Include
```csharp
var queryConRelaciones = CategoriaService.Query()
    .Where(c => c.Activo == true)
    .Include(c => c.CategoriaPadre)
    .Include(c => c.Subcategorias);
```

## API Reference

### Métodos Públicos
```csharp
// Refrescar datos manualmente
public async Task RefreshData()

// Invalidar cache manualmente  
public void InvalidateCache()
```

### Eventos
```csharp
// Cambio de valor
[Parameter] public EventCallback<TValue> ValueChanged { get; set; }

// Botón agregar personalizado
[Parameter] public EventCallback Add { get; set; }
```

## Arquitectura Interna

### Flujo con Cache Habilitado
1. **Primera carga**: `LoadCompleteDataset()` → API call con `Top=50000`
2. **Cache storage**: Guarda en `CacheService` con TTL
3. **Búsquedas**: `FilterDataInMemory()` → Filtrado instantáneo
4. **Paginación**: `ApplyPaginationInMemory()` → En memoria

### Flujo sin Cache  
1. **Cada búsqueda**: API call normal con paginación
2. **Filtros**: Se envían al backend via QueryBuilder
3. **Performance**: Depende de la base de datos

### Invalidación Inteligente
- **Al crear**: Cache se invalida automáticamente
- **Por patrón**: `lookup_full_{EntityName}_*` 
- **Por clave**: `lookup_full_{CacheKey}`

## Conclusión

El componente Lookup es una solución completa para selección de datos que combina:
- **Performance** con cache inteligente
- **Type Safety** con campos buscables tipados  
- **Flexibilidad** con QueryBuilder y OnLoad personalizado
- **Usabilidad** con creación rápida integrada

Es ideal para cualquier escenario donde necesites un selector avanzado con búsqueda, desde catálogos simples hasta selecciones complejas con filtros múltiples.