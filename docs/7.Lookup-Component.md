# Componente Lookup - Gu√≠a Completa

## Descripci√≥n General

El componente `Lookup` es un selector avanzado basado en `RadzenDropDownDataGrid` que proporciona funcionalidades de b√∫squeda, filtrado, cache inteligente y creaci√≥n r√°pida de elementos. Est√° dise√±ado para ser fuertemente tipado y altamente configurable.

## Caracter√≠sticas Principales

- ‚úÖ **B√∫squeda fuertemente tipada** con campos espec√≠ficos
- ‚úÖ **Cache inteligente** con TTL configurable  
- ‚úÖ **Filtrado en memoria** para performance √≥ptima
- ‚úÖ **Creaci√≥n r√°pida** de elementos con modal
- ‚úÖ **QueryBuilder integration** para filtros base
- ‚úÖ **OnLoad personalizado** para l√≥gica avanzada
- ‚úÖ **Auto-invalidaci√≥n** de cache al crear elementos

## Par√°metros Principales

### Par√°metros B√°sicos
```csharp
[Parameter] public TValue Value { get; set; }                    // Valor seleccionado
[Parameter] public EventCallback<TValue> ValueChanged { get; set; } // Evento de cambio
[Parameter] public BaseApiService<TEntity> Service { get; set; } // Servicio de datos
[Parameter] public string DisplayProperty { get; set; } = "Nombre"; // Propiedad a mostrar
[Parameter] public string ValueProperty { get; set; } = "Id";    // Propiedad del valor
[Parameter] public string Placeholder { get; set; } = "Seleccionar..."; // Placeholder
```

### Par√°metros de Cache (NUEVO)
```csharp
[Parameter] public bool EnableCache { get; set; } = false;       // Habilitar cache
[Parameter] public TimeSpan? CacheTTL { get; set; } = TimeSpan.FromMinutes(5); // Tiempo de vida
[Parameter] public string? CacheKey { get; set; }                // Clave personalizada
```

### Par√°metros de B√∫squeda (NUEVO)
```csharp
[Parameter] public Expression<Func<TEntity, object>>[]? SearchableFields { get; set; } // Campos buscables
[Parameter] public bool ShowSearch { get; set; } = true;         // Mostrar b√∫squeda
```

### Par√°metros de Creaci√≥n
```csharp
[Parameter] public bool ShowAdd { get; set; } = true;            // Mostrar bot√≥n +
[Parameter] public EventCallback Add { get; set; }               // Callback personalizado
[Parameter] public Type? FastCreateComponentType { get; set; }   // Componente para crear
[Parameter] public string EntityDisplayName { get; set; } = "elemento"; // Nombre para UI
```

### Par√°metros Avanzados
```csharp
[Parameter] public QueryBuilder<TEntity>? BaseQuery { get; set; } // Filtro base
[Parameter] public RenderFragment? ColumnsTemplate { get; set; }  // Template de columnas
[Parameter] public string ModalWidth { get; set; } = "400px";     // Ancho del modal
[Parameter] public string ModalHeight { get; set; } = "600px";    // Alto del modal
[Parameter] public Func<LoadDataArgs, QueryBuilder<TEntity>?, Task<ApiResponse<PagedResult<TEntity>>>>? OnLoad { get; set; } // Carga personalizada
```

## Uso B√°sico

### Ejemplo Simple
```razor
<Lookup TEntity="Categoria" 
       TValue="Guid?" 
       @bind-Value="categoriaId"
       Service="CategoriaService"
       EntityDisplayName="Categor√≠a" />
```

### Ejemplo con Cache y Campos Buscables
```razor
@* En el .razor.cs *@
private Expression<Func<Categoria, object>>[] categoriaSearchFields = 
    SearchFields<Categoria>(c => c.Nombre, c => c.Descripcion);

@* En el .razor *@
<Lookup TEntity="Categoria" 
       TValue="Guid?" 
       @bind-Value="categoriaId"
       Service="CategoriaService"
       SearchableFields="@categoriaSearchFields"
       EnableCache="true"
       CacheTTL="TimeSpan.FromMinutes(10)"
       CacheKey="categorias_activas"
       EntityDisplayName="Categor√≠a" />
```

## Configuraciones de Cache

### Cache para Datos Est√°ticos (Recomendado)
```razor
@* Cat√°logos que cambian poco - TTL largo *@
<Lookup TEntity="Pais" 
       EnableCache="true"
       CacheTTL="TimeSpan.FromHours(2)"
       CacheKey="paises_activos" />
```

### Cache para Datos Semi-Din√°micos
```razor
@* Datos que cambian ocasionalmente - TTL mediano *@
<Lookup TEntity="Usuario" 
       EnableCache="true"
       CacheTTL="TimeSpan.FromMinutes(5)"
       CacheKey="usuarios_activos" />
```

### Sin Cache para Datos Din√°micos
```razor
@* Datos que cambian frecuentemente - Sin cache *@
<Lookup TEntity="Pedido" 
       EnableCache="false" />
```

## Campos Buscables Fuertemente Tipados

### Helper Method (Recomendado)
```csharp
// En tu componente .cs
private static Expression<Func<T, object>>[] SearchFields<T>(params Expression<Func<T, object>>[] fields)
{
    return fields;
}

// Configurar campos espec√≠ficos
private Expression<Func<Categoria, object>>[] categoriaFields = 
    SearchFields<Categoria>(c => c.Nombre, c => c.Descripcion);

private Expression<Func<Usuario, object>>[] usuarioFields = 
    SearchFields<Usuario>(u => u.Nombre, u => u.Email, u => u.Telefono);
```

### Uso en el Lookup
```razor
<Lookup SearchableFields="@categoriaFields" />  @* Solo busca en Nombre y Descripci√≥n *@
<Lookup SearchableFields="@usuarioFields" />    @* Busca en Nombre, Email y Tel√©fono *@
<Lookup />                                       @* Busca en todas las propiedades string *@
```

## QueryBuilder Integration

### Filtros Base
```csharp
// En OnInitialized()
var baseFilter = CategoriaService.Query()
    .Where(c => c.Activo == true)
    .Where(c => c.Nombre.StartsWith("A"));

// Combinaciones
var otherFilter = CategoriaService.Query().Where(c => c.Descripcion != null);
var combined = baseFilter.And(otherFilter);  // A + Descripci√≥n no null
var alternative = baseFilter.Or(otherFilter); // A OR Descripci√≥n no null
```

```razor
<Lookup BaseQuery="@baseFilter" />       @* Solo categor√≠as activas que empiecen con A *@
<Lookup BaseQuery="@combined" />         @* Filtro combinado con AND *@
<Lookup BaseQuery="@alternative" />      @* Filtro combinado con OR *@
```

## OnLoad Personalizado

### Ejemplo con Logging y Transformaciones
```csharp
private Func<LoadDataArgs, QueryBuilder<Categoria>?, Task<ApiResponse<PagedResult<Categoria>>>>? customOnLoad;

protected override void OnInitialized()
{
    customOnLoad = async (args, query) =>
    {
        // Logging personalizado
        Console.WriteLine($"Cargando datos: Skip={args.Skip}, Top={args.Top}, Filter={args.Filter}");
        
        // L√≥gica de carga con query combinado
        var result = query != null 
            ? await CategoriaService.LoadDataAsync(args, query)
            : await CategoriaService.LoadDataAsync(args);
        
        // Transformaciones post-carga
        if (result.Success && result.Data?.Data != null)
        {
            foreach (var item in result.Data.Data)
            {
                // Ejemplo: agregar prefijo a nombres
                if (!item.Nombre.StartsWith("[CACHE]"))
                    item.Nombre = $"[CACHE] {item.Nombre}";
            }
        }
        
        return result;
    };
}
```

```razor
<Lookup OnLoad="@customOnLoad" />
```

## Creaci√≥n R√°pida de Elementos

### Con Componente Fast
```csharp
// Fast.razor debe devolver la entidad creada
public partial class Fast : ComponentBase
{
    [Parameter] public EventCallback<Categoria> OnSave { get; set; }
    
    private async Task Save()
    {
        // ... l√≥gica de guardado ...
        if (response.Success && response.Data != null)
        {
            await DialogService.CloseAsync(response.Data); // ‚Üê Devolver la entidad
        }
    }
}
```

```razor
<Lookup FastCreateComponentType="typeof(Fast)"
       ModalWidth="500px"
       ModalHeight="400px" />
```

### Con Callback Personalizado
```csharp
private async Task HandleAddCategoria()
{
    // Tu l√≥gica personalizada para crear
    var nuevaCategoria = await MiLogicaPersonalizada();
    
    // El Lookup se actualizar√° autom√°ticamente
}
```

```razor
<Lookup Add="@HandleAddCategoria" 
       ShowAdd="true" />
```

## Ejemplos Completos

### Lookup B√°sico sin Cache
```razor
<RadzenFormField Text="Usuario Asignado">
    <Lookup TEntity="Usuario" 
           TValue="Guid?" 
           @bind-Value="usuarioId"
           Service="UsuarioService"
           DisplayProperty="NombreCompleto"
           EntityDisplayName="Usuario"
           ShowAdd="false" />
</RadzenFormField>
```

### Lookup con Cache y B√∫squeda Espec√≠fica
```razor
@* En .razor.cs *@
private Expression<Func<Cliente, object>>[] clienteFields = 
    SearchFields<Cliente>(c => c.RazonSocial, c => c.CUIT, c => c.Email);

@* En .razor *@
<RadzenFormField Text="Cliente">
    <Lookup TEntity="Cliente" 
           TValue="Guid?" 
           @bind-Value="clienteId"
           Service="ClienteService"
           SearchableFields="@clienteFields"
           EnableCache="true"
           CacheTTL="TimeSpan.FromMinutes(15)"
           CacheKey="clientes_activos"
           EntityDisplayName="Cliente"
           FastCreateComponentType="typeof(ClienteFast)"
           ModalWidth="800px"
           ModalHeight="600px" />
</RadzenFormField>
```

### Lookup con Filtro Base y OnLoad
```csharp
// En .razor.cs
private QueryBuilder<Producto>? productosActivos;
private Expression<Func<Producto, object>>[] productoFields = 
    SearchFields<Producto>(p => p.Nombre, p => p.Codigo, p => p.Categoria.Nombre);

private Func<LoadDataArgs, QueryBuilder<Producto>?, Task<ApiResponse<PagedResult<Producto>>>>? onLoadProductos;

protected override void OnInitialized()
{
    // Filtro base: solo productos activos
    productosActivos = ProductoService.Query()
        .Where(p => p.Activo == true)
        .Where(p => p.Stock > 0);
    
    // OnLoad personalizado con logging
    onLoadProductos = async (args, query) =>
    {
        Logger.LogInformation($"Cargando productos - Filtro: {args.Filter}");
        
        var result = await ProductoService.LoadDataAsync(args, query);
        
        // Agregar informaci√≥n de stock en tiempo real
        if (result.Success && result.Data?.Data != null)
        {
            foreach (var producto in result.Data.Data)
            {
                var stockActual = await StockService.GetStockActualAsync(producto.Id);
                producto.StockActual = stockActual;
            }
        }
        
        return result;
    };
}
```

```razor
<RadzenFormField Text="Producto">
    <Lookup TEntity="Producto" 
           TValue="Guid?" 
           @bind-Value="productoId"
           Service="ProductoService"
           BaseQuery="@productosActivos"
           SearchableFields="@productoFields"
           OnLoad="@onLoadProductos"
           EnableCache="true"
           CacheTTL="TimeSpan.FromMinutes(2)"
           EntityDisplayName="Producto">
        
        <ColumnsTemplate>
            <RadzenDropDownDataGridColumn Property="Codigo" Title="C√≥digo" Width="100px" />
            <RadzenDropDownDataGridColumn Property="Nombre" Title="Nombre" Width="200px" />
            <RadzenDropDownDataGridColumn Property="Stock" Title="Stock" Width="80px" />
        </ColumnsTemplate>
        
    </Lookup>
</RadzenFormField>
```

## Mejores Pr√°cticas

### ‚úÖ Cu√°ndo Usar Cache
- **Cat√°logos est√°ticos**: Pa√≠ses, estados, categor√≠as (TTL: 1-2 horas)
- **Datos de referencia**: Usuarios, clientes, proveedores (TTL: 5-15 minutos)
- **Configuraciones**: Par√°metros del sistema (TTL: 30-60 minutos)

### ‚ùå Cu√°ndo NO Usar Cache
- **Datos transaccionales**: Pedidos, facturas, movimientos
- **Datos en tiempo real**: Stock en vivo, precios din√°micos
- **Datos personales**: Informaci√≥n del usuario actual

### üéØ Campos Buscables
```csharp
// ‚úÖ BUENO - Campos relevantes para el usuario
SearchFields<Cliente>(c => c.RazonSocial, c => c.CUIT, c => c.Email)

// ‚ùå MALO - Demasiados campos irrelevantes  
SearchFields<Cliente>(c => c.Id, c => c.FechaCreacion, c => c.UsuarioCreacion)

// ‚úÖ BUENO - Sin especificar = busca en todas las string properties
// No especificar SearchableFields para entidades simples
```

### üîë Cache Keys
```csharp
// ‚úÖ BUENO - Descriptivas y √∫nicas
CacheKey="categorias_activas_departamento_ventas"
CacheKey="usuarios_habilitados_sucursal_central"

// ‚ùå MALO - Gen√©ricas o confusas
CacheKey="data"
CacheKey="lookup1"
```

## Invalidaci√≥n de Cache

### Autom√°tica
El cache se invalida autom√°ticamente cuando:
- Se crea un nuevo elemento desde el Lookup
- Se usa el callback `Add` personalizado

### Manual
```csharp
// Desde c√≥digo
lookupRef.InvalidateCache();

// Desde servicios despu√©s de operaciones CRUD
CacheService.RemoveByPattern("categorias_*");
```

## Troubleshooting

### Performance
- **Problema**: Lookup lento en primera carga
- **Soluci√≥n**: Habilitar cache con `EnableCache="true"`

### B√∫squeda
- **Problema**: No encuentra elementos que deber√≠an existir  
- **Soluci√≥n**: Verificar `SearchableFields` - asegurar que incluye los campos correctos

### Cache
- **Problema**: Datos desactualizados en el Lookup
- **Soluci√≥n**: Reducir `CacheTTL` o invalidar manualmente

### Memory
- **Problema**: Uso excesivo de memoria
- **Soluci√≥n**: Usar cache solo para datasets peque√±os (&lt;10,000 registros)

## Ejemplos de Configuraci√≥n por Escenario

### 1. Cat√°logo de Pa√≠ses (Datos Est√°ticos)
```csharp
private Expression<Func<Pais, object>>[] paisFields = 
    SearchFields<Pais>(p => p.Nombre, p => p.Codigo);
```
```razor
<Lookup TEntity="Pais" 
       SearchableFields="@paisFields"
       EnableCache="true"
       CacheTTL="TimeSpan.FromHours(24)"
       CacheKey="paises_todos"
       ShowAdd="false" />
```

### 2. Selector de Clientes (Datos Semi-Din√°micos)
```csharp
private QueryBuilder<Cliente>? clientesActivos = 
    ClienteService.Query().Where(c => c.Activo == true);

private Expression<Func<Cliente, object>>[] clienteFields = 
    SearchFields<Cliente>(c => c.RazonSocial, c => c.CUIT, c => c.Email);
```
```razor
<Lookup TEntity="Cliente" 
       BaseQuery="@clientesActivos"
       SearchableFields="@clienteFields"
       EnableCache="true"
       CacheTTL="TimeSpan.FromMinutes(10)"
       FastCreateComponentType="typeof(ClienteFast)"
       ModalWidth="800px" />
```

### 3. Selector de Productos (Con Stock en Tiempo Real)
```csharp
private Func<LoadDataArgs, QueryBuilder<Producto>?, Task<ApiResponse<PagedResult<Producto>>>>? onLoadProductos;

protected override void OnInitialized()
{
    onLoadProductos = async (args, query) =>
    {
        var result = await ProductoService.LoadDataAsync(args, query);
        
        // Enriquecer con informaci√≥n de stock en tiempo real
        if (result.Success && result.Data?.Data != null)
        {
            foreach (var producto in result.Data.Data)
            {
                producto.StockDisponible = await StockService.GetDisponibleAsync(producto.Id);
            }
        }
        
        return result;
    };
}
```
```razor
<Lookup TEntity="Producto" 
       OnLoad="@onLoadProductos"
       EnableCache="false"  @* Sin cache por datos din√°micos *@
       SearchableFields="@SearchFields<Producto>(p => p.Nombre, p => p.Codigo)" />
```

## Integraci√≥n con QueryBuilder

### Filtros Complejos
```csharp
// Filtros base complejos
var filtroAvanzado = CategoriaService.Query()
    .Where(c => c.Activo == true)
    .Where(c => c.FechaCreacion >= DateTime.Now.AddMonths(-6))
    .Where(c => c.Departamento == "Ventas");

// Combinar con otros filtros
var filtroAdicional = CategoriaService.Query()
    .Where(c => c.Prioridad == "Alta");

var filtroFinal = filtroAvanzado.And(filtroAdicional);
```

### Uso con Include
```csharp
var queryConRelaciones = CategoriaService.Query()
    .Where(c => c.Activo == true)
    .Include(c => c.CategoriaPadre)
    .Include(c => c.Subcategorias);
```

## API Reference

### M√©todos P√∫blicos
```csharp
// Refrescar datos manualmente
public async Task RefreshData()

// Invalidar cache manualmente  
public void InvalidateCache()
```

### Eventos
```csharp
// Cambio de valor
[Parameter] public EventCallback<TValue> ValueChanged { get; set; }

// Bot√≥n agregar personalizado
[Parameter] public EventCallback Add { get; set; }
```

## Arquitectura Interna

### Flujo con Cache Habilitado
1. **Primera carga**: `LoadCompleteDataset()` ‚Üí API call con `Top=50000`
2. **Cache storage**: Guarda en `CacheService` con TTL
3. **B√∫squedas**: `FilterDataInMemory()` ‚Üí Filtrado instant√°neo
4. **Paginaci√≥n**: `ApplyPaginationInMemory()` ‚Üí En memoria

### Flujo sin Cache  
1. **Cada b√∫squeda**: API call normal con paginaci√≥n
2. **Filtros**: Se env√≠an al backend via QueryBuilder
3. **Performance**: Depende de la base de datos

### Invalidaci√≥n Inteligente
- **Al crear**: Cache se invalida autom√°ticamente
- **Por patr√≥n**: `lookup_full_{EntityName}_*` 
- **Por clave**: `lookup_full_{CacheKey}`

## Conclusi√≥n

El componente Lookup es una soluci√≥n completa para selecci√≥n de datos que combina:
- **Performance** con cache inteligente
- **Type Safety** con campos buscables tipados  
- **Flexibilidad** con QueryBuilder y OnLoad personalizado
- **Usabilidad** con creaci√≥n r√°pida integrada

Es ideal para cualquier escenario donde necesites un selector avanzado con b√∫squeda, desde cat√°logos simples hasta selecciones complejas con filtros m√∫ltiples.