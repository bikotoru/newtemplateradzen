# Sistema de Operaciones por Lotes (Batch) - Documentación

## Resumen del Sistema

Sistema completo de **operaciones por lotes** para **crear, actualizar y eliminar múltiples entidades** de forma eficiente. Incluye **transacciones**, **manejo de errores granular**, **validaciones automáticas** y **continuidad opcional** en caso de fallos.

## Arquitectura de Archivos

### Backend
- `Backend.Utils/Services/BaseQueryService.cs` - Lógica de batch operations con transacciones
- `Backend/Controllers/BaseQueryController.cs` - Endpoints para operaciones por lotes

### Shared
- `Shared.Models/Requests/CreateBatchRequest.cs` - Request para creación masiva
- `Shared.Models/Requests/UpdateBatchRequest.cs` - Request para actualización masiva
- `Shared.Models/Requests/DeleteBatchRequest.cs` - Request para eliminación masiva
- `Shared.Models/Responses/BatchResponse.cs` - Response con resultados detallados

## Endpoints Disponibles

### Operaciones por Lotes
- `POST /api/{entity}/create-batch` - Crear múltiples entidades
- `PUT /api/{entity}/update-batch` - Actualizar múltiples entidades
- `DELETE /api/{entity}/delete-batch` - Eliminar múltiples entidades

## Request Models

### CreateBatchRequest<T>
```csharp
public class CreateBatchRequest<T>
{
    public List<CreateRequest<T>> Requests { get; set; } = new();  // Lista de requests individuales
    public bool ContinueOnError { get; set; } = false;            // Continuar si hay errores
    public bool UseTransaction { get; set; } = true;              // Usar transacción DB
    public bool ValidateForeignKeys { get; set; } = true;         // Validar FKs
    public bool ValidateUniqueConstraints { get; set; } = true;   // Validar campos únicos
    public int BatchSize { get; set; } = 100;                     // Tamaño del lote
    public Dictionary<string, object>? AdditionalData { get; set; } // Datos adicionales
}
```

### UpdateBatchRequest<T>
```csharp
public class UpdateBatchRequest<T>
{
    public List<UpdateRequest<T>> Requests { get; set; } = new();  // Lista de requests individuales
    public bool ContinueOnError { get; set; } = false;            // Continuar si hay errores
    public bool UseTransaction { get; set; } = true;              // Usar transacción DB
    public bool ValidateForeignKeys { get; set; } = true;         // Validar FKs
    public bool ValidateExistence { get; set; } = true;           // Validar que existan
    public int BatchSize { get; set; } = 100;                     // Tamaño del lote
    public Dictionary<string, object>? AdditionalData { get; set; } // Datos adicionales
}
```

### DeleteBatchRequest
```csharp
public class DeleteBatchRequest
{
    public List<Guid> Ids { get; set; } = new();                  // IDs a eliminar
    public bool ContinueOnError { get; set; } = false;            // Continuar si hay errores
    public bool UseTransaction { get; set; } = true;              // Usar transacción DB
    public bool ValidateExistence { get; set; } = true;           // Validar que existan
    public bool SoftDelete { get; set; } = true;                  // Eliminación lógica
    public int BatchSize { get; set; } = 100;                     // Tamaño del lote
}
```

## Response Model

### BatchResponse<T>
```csharp
public class BatchResponse<T>
{
    public List<T>? SuccessfulOperations { get; set; } = new();           // Operaciones exitosas
    public List<BatchOperationError>? FailedOperations { get; set; } = new(); // Operaciones fallidas
    public int TotalProcessed { get; set; }                               // Total procesadas
    public int SuccessCount { get; set; }                                 // Exitosas
    public int FailureCount { get; set; }                                 // Fallidas
    public bool ContinuedOnError { get; set; }                            // Si continuó con errores
    public TimeSpan ProcessingTime { get; set; }                          // Tiempo de procesamiento
    public bool UsedTransaction { get; set; }                             // Si usó transacción
    public Dictionary<string, object>? Metadata { get; set; }             // Metadatos adicionales
}

public class BatchOperationError
{
    public int Index { get; set; }                    // Índice en el lote
    public string ErrorMessage { get; set; } = "";   // Mensaje de error
    public string? ErrorCode { get; set; }           // Código de error
    public object? OriginalData { get; set; }        // Datos originales
    public List<string>? ValidationErrors { get; set; } // Errores de validación
}
```

## Creación por Lotes

### 1. Crear Múltiples Entidades - Básico
```csharp
public async Task<ApiResponse<BatchResponse<Categoria>>> CrearCategoriasAsync(
    List<Categoria> categorias)
{
    var requests = categorias.Select(c => 
        new CreateRequestBuilder<Categoria>(c)
            .WithFields(cat => cat.Nombre, cat => cat.Descripcion, cat => cat.Codigo)
            .Build()
    ).ToList();

    var batchRequest = new CreateBatchRequest<Categoria>
    {
        Requests = requests,
        UseTransaction = true,      // Todo o nada
        ContinueOnError = false     // Parar al primer error
    };

    return await CreateBatchAsync(batchRequest);
}
```

### 2. Crear con Tolerancia a Errores
```csharp
public async Task<ApiResponse<BatchResponse<Categoria>>> ImportarCsvAsync(
    List<Categoria> categorias)
{
    var requests = categorias.Select(c => 
        new CreateRequestBuilder<Categoria>(c)
            .WithFields(cat => cat.Nombre, cat => cat.Descripcion, cat => cat.CreadorId)
            .Including("Creador")
            .Build()
    ).ToList();

    var batchRequest = new CreateBatchRequest<Categoria>
    {
        Requests = requests,
        ContinueOnError = true,             // Continúa aunque fallen algunas
        UseTransaction = false,             // No usar transacción global
        ValidateForeignKeys = true,         // Validar CreadorId
        BatchSize = 50,                     // Procesar de 50 en 50
        AdditionalData = new Dictionary<string, object>
        {
            { "ImportSource", "CSV" },
            { "ImportDate", DateTime.Now }
        }
    };

    return await CreateBatchAsync(batchRequest);
}
```

### 3. Crear con Validaciones Personalizadas
```csharp
public async Task<ApiResponse<BatchResponse<Usuario>>> CrearUsuariosAsync(
    List<Usuario> usuarios)
{
    var requests = usuarios.Select(u => 
        new CreateRequestBuilder<Usuario>(u)
            .WithFields(user => user.Nombre, user => user.Email, user => user.Password)
            .Build()
    ).ToList();

    var batchRequest = new CreateBatchRequest<Usuario>
    {
        Requests = requests,
        ValidateUniqueConstraints = true,   // Validar emails únicos
        ValidateForeignKeys = true,
        ContinueOnError = true,
        BatchSize = 25
    };

    return await CreateBatchAsync(batchRequest);
}
```

## Actualización por Lotes

### 1. Actualizar Múltiples Campos
```csharp
public async Task<ApiResponse<BatchResponse<Categoria>>> ActualizarEstadoAsync(
    List<Guid> ids, bool nuevoEstado)
{
    var requests = ids.Select(id => 
    {
        var categoria = new Categoria { Id = id, Active = nuevoEstado };
        return new UpdateRequestBuilder<Categoria>(categoria)
            .WithFields(c => c.Active)  // Solo actualizar el estado
            .Build();
    }).ToList();

    var batchRequest = new UpdateBatchRequest<Categoria>
    {
        Requests = requests,
        UseTransaction = true,          // Actualizar todo o nada
        ValidateExistence = true,       // Validar que existan
        ContinueOnError = false
    };

    return await UpdateBatchAsync(batchRequest);
}
```

### 2. Actualización Masiva con Datos Diferentes
```csharp
public async Task<ApiResponse<BatchResponse<Categoria>>> ActualizarDesdePlanillaAsync(
    List<CategoriaUpdate> updates)
{
    var requests = updates.Select(update => 
    {
        var categoria = new Categoria 
        { 
            Id = update.Id, 
            Nombre = update.Nombre,
            Descripcion = update.Descripcion,
            Codigo = update.Codigo
        };
        
        return new UpdateRequestBuilder<Categoria>(categoria)
            .WithFields(c => c.Nombre, c => c.Descripcion, c => c.Codigo)
            .Build();
    }).ToList();

    var batchRequest = new UpdateBatchRequest<Categoria>
    {
        Requests = requests,
        ContinueOnError = true,         // Continuar si algunos fallan
        ValidateExistence = true,
        ValidateForeignKeys = false,    // No validar FK en esta operación
        BatchSize = 100
    };

    return await UpdateBatchAsync(batchRequest);
}
```

### 3. Actualización con Relaciones
```csharp
public async Task<ApiResponse<BatchResponse<Categoria>>> ReasignarCreadorAsync(
    List<Guid> categoriaIds, Guid nuevoCreadorId)
{
    var requests = categoriaIds.Select(id => 
    {
        var categoria = new Categoria { Id = id, CreadorId = nuevoCreadorId };
        return new UpdateRequestBuilder<Categoria>(categoria)
            .WithFields(c => c.CreadorId)
            .Including("Creador")           // Incluir nueva relación
            .WithUpdateRelations(true)
            .Build();
    }).ToList();

    var batchRequest = new UpdateBatchRequest<Categoria>
    {
        Requests = requests,
        ValidateForeignKeys = true,     // Validar que el nuevo creador exista
        UseTransaction = true,
        ContinueOnError = false
    };

    return await UpdateBatchAsync(batchRequest);
}
```

## Eliminación por Lotes

### 1. Eliminación Lógica (Soft Delete)
```csharp
public async Task<ApiResponse<BatchResponse<object>>> EliminarCategoriasAsync(
    List<Guid> ids)
{
    var batchRequest = new DeleteBatchRequest
    {
        Ids = ids,
        SoftDelete = true,              // Eliminación lógica (Active = false)
        UseTransaction = true,          // Todo o nada
        ValidateExistence = true,       // Validar que existan
        ContinueOnError = false
    };

    return await DeleteBatchAsync(batchRequest);
}
```

### 2. Eliminación Física con Tolerancia
```csharp
public async Task<ApiResponse<BatchResponse<object>>> LimpiezaBaseDatosAsync(
    List<Guid> idsObsoletos)
{
    var batchRequest = new DeleteBatchRequest
    {
        Ids = idsObsoletos,
        SoftDelete = false,             // Eliminación física
        ContinueOnError = true,         // Continuar aunque algunos fallen
        UseTransaction = false,         // No usar transacción global
        ValidateExistence = false,      // No validar existencia
        BatchSize = 20                  // Lotes pequeños para eliminación física
    };

    return await DeleteBatchAsync(batchRequest);
}
```

## Manejo de Respuestas Batch

### 1. Análisis Completo de Resultados
```csharp
private async Task AnalizarResultadoBatch<T>(ApiResponse<BatchResponse<T>> response)
{
    if (!response.Success)
    {
        Console.WriteLine($"Error en batch: {response.Message}");
        return;
    }

    var batch = response.Data;
    if (batch == null) return;

    // Estadísticas generales
    Console.WriteLine($"=== RESULTADOS BATCH ===");
    Console.WriteLine($"Total procesadas: {batch.TotalProcessed}");
    Console.WriteLine($"Exitosas: {batch.SuccessCount}");
    Console.WriteLine($"Fallidas: {batch.FailureCount}");
    Console.WriteLine($"Tiempo: {batch.ProcessingTime.TotalSeconds:F2}s");
    Console.WriteLine($"Usó transacción: {batch.UsedTransaction}");

    // Errores detallados
    if (batch.FailedOperations?.Any() == true)
    {
        Console.WriteLine("\n=== ERRORES ===");
        foreach (var error in batch.FailedOperations)
        {
            Console.WriteLine($"Índice {error.Index}: {error.ErrorMessage}");
            if (error.ValidationErrors?.Any() == true)
            {
                foreach (var validationError in error.ValidationErrors)
                {
                    Console.WriteLine($"  - Validación: {validationError}");
                }
            }
        }
    }

    // Metadatos
    if (batch.Metadata?.Any() == true)
    {
        Console.WriteLine("\n=== METADATOS ===");
        foreach (var meta in batch.Metadata)
        {
            Console.WriteLine($"{meta.Key}: {meta.Value}");
        }
    }
}
```

### 2. Manejo de Errores en UI
```csharp
// En un componente Blazor
private async Task ProcesarLoteAsync()
{
    loadingBatch = true;
    try
    {
        var response = await categoriaService.CreateBatchAsync(batchRequest);
        
        if (response.Success && response.Data != null)
        {
            var batch = response.Data;
            
            // Mostrar resultados en UI
            mensajeExito = $"Procesadas: {batch.SuccessCount}/{batch.TotalProcessed}";
            
            if (batch.FailureCount > 0)
            {
                // Construir mensaje de errores para mostrar al usuario
                var errores = batch.FailedOperations?
                    .Take(5)  // Solo primeros 5 errores
                    .Select(e => $"Fila {e.Index + 1}: {e.ErrorMessage}")
                    .ToList();
                    
                mensajeError = string.Join("\n", errores ?? new List<string>());
                
                if (batch.FailureCount > 5)
                {
                    mensajeError += $"\n... y {batch.FailureCount - 5} errores más";
                }
            }
        }
        else
        {
            mensajeError = response.Message;
        }
    }
    finally
    {
        loadingBatch = false;
        StateHasChanged();
    }
}
```

## Patrones Avanzados

### 1. Batch Escalonado (Staged Batch)
```csharp
public async Task<List<BatchResponse<Categoria>>> ImportarEscalonadoAsync(
    List<Categoria> todasLasCategorias)
{
    var resultados = new List<BatchResponse<Categoria>>();
    const int batchSize = 50;
    
    for (int i = 0; i < todasLasCategorias.Count; i += batchSize)
    {
        var lote = todasLasCategorias.Skip(i).Take(batchSize).ToList();
        
        var requests = lote.Select(c => 
            new CreateRequestBuilder<Categoria>(c)
                .WithFields(cat => cat.Nombre, cat => cat.Descripcion)
                .Build()
        ).ToList();

        var batchRequest = new CreateBatchRequest<Categoria>
        {
            Requests = requests,
            ContinueOnError = true,
            BatchSize = batchSize,
            AdditionalData = new Dictionary<string, object>
            {
                { "LoteNumero", (i / batchSize) + 1 },
                { "TotalLotes", Math.Ceiling((double)todasLasCategorias.Count / batchSize) }
            }
        };

        var response = await CreateBatchAsync(batchRequest);
        if (response.Success && response.Data != null)
        {
            resultados.Add(response.Data);
        }
        
        // Pausa entre lotes para no sobrecargar el servidor
        await Task.Delay(500);
    }
    
    return resultados;
}
```

### 2. Batch con Retry Automático
```csharp
public async Task<ApiResponse<BatchResponse<Categoria>>> CrearConRetryAsync(
    List<Categoria> categorias, int maxReintentos = 3)
{
    ApiResponse<BatchResponse<Categoria>>? response = null;
    List<CreateRequest<Categoria>> pendientes = categorias.Select(c => 
        new CreateRequestBuilder<Categoria>(c)
            .WithFields(cat => cat.Nombre, cat => cat.Descripcion)
            .Build()
    ).ToList();

    for (int intento = 1; intento <= maxReintentos; intento++)
    {
        var batchRequest = new CreateBatchRequest<Categoria>
        {
            Requests = pendientes,
            ContinueOnError = true,
            AdditionalData = new Dictionary<string, object>
            {
                { "Intento", intento },
                { "MaxIntentos", maxReintentos }
            }
        };

        response = await CreateBatchAsync(batchRequest);
        
        if (response.Success && response.Data != null)
        {
            // Si no hay fallos, terminar
            if (response.Data.FailureCount == 0)
                break;
                
            // Si es el último intento, terminar
            if (intento == maxReintentos)
                break;
                
            // Preparar reintentos solo para las fallidas
            var indicesFallidos = response.Data.FailedOperations?
                .Select(f => f.Index)
                .ToHashSet() ?? new HashSet<int>();
                
            pendientes = pendientes
                .Where((req, index) => indicesFallidos.Contains(index))
                .ToList();
                
            // Esperar antes del siguiente intento
            await Task.Delay(TimeSpan.FromSeconds(Math.Pow(2, intento))); // Backoff exponencial
        }
    }

    return response ?? ApiResponse<BatchResponse<Categoria>>.ErrorResponse("No se pudo completar el batch");
}
```

### 3. Validación Previa al Batch
```csharp
public async Task<(bool isValid, List<string> errors)> ValidarAntesDeCrearAsync(
    List<Categoria> categorias)
{
    var errores = new List<string>();
    
    // Validaciones de negocio
    var nombresVacios = categorias
        .Where(c => string.IsNullOrWhiteSpace(c.Nombre))
        .Count();
    if (nombresVacios > 0)
        errores.Add($"{nombresVacios} categorías sin nombre");
    
    // Validar duplicados en el lote
    var duplicados = categorias
        .GroupBy(c => c.Codigo)
        .Where(g => g.Count() > 1)
        .Select(g => g.Key)
        .ToList();
    if (duplicados.Any())
        errores.Add($"Códigos duplicados: {string.Join(", ", duplicados)}");
    
    // Validar FKs existentes (ejemplo)
    var creadorIds = categorias.Select(c => c.CreadorId).Distinct().ToList();
    var usuariosExistentes = await usuarioService.ValidateExistenceAsync(creadorIds);
    if (!usuariosExistentes.Success)
        errores.Add("Error validando usuarios creadores");
    
    return (errores.Count == 0, errores);
}
```

## Monitoreo y Performance

### 1. Métricas de Batch
```csharp
public class BatchMetrics
{
    public int TotalItems { get; set; }
    public int ItemsPerSecond => TotalItems / Math.Max(1, (int)TotalTime.TotalSeconds);
    public TimeSpan TotalTime { get; set; }
    public int BatchCount { get; set; }
    public double SuccessRate => TotalItems == 0 ? 0 : (double)SuccessfulItems / TotalItems * 100;
    public int SuccessfulItems { get; set; }
    public int FailedItems { get; set; }
}
```

**¡El sistema Batch está completo!** Incluye **transacciones**, **tolerancia a errores**, **validaciones automáticas**, **retry logic** y **monitoreo de performance** para operaciones masivas eficientes y robustas.