# Sistema de Query y Search - Documentación

## Resumen del Sistema

Sistema completo de CRUD con **Query Builder fuertemente tipado** y **búsqueda inteligente** para aplicaciones .NET 9.0 + Blazor WebAssembly. Incluye integración nativa con **RadzenDataGrid**.

## Arquitectura de Archivos

### Backend
- `Backend.Utils/Services/BaseQueryService.cs` - Servicio base con lógica CRUD, Query y Search
- `Backend/Controllers/BaseQueryController.cs` - Controlador base con endpoints virtuales
- `Backend/Controllers/CategoriaController.cs` - Implementación específica que hereda de BaseQueryController

### Frontend
- `Frontend/Services/BaseApiService.cs` - Servicio base con métodos HTTP y QueryBuilder
- `Frontend/Modules/Categoria/CategoriaService.cs` - Servicio específico que hereda de BaseApiService

### Shared
- `Shared.Models/Services/QueryService.cs` - QueryBuilder principal fuertemente tipado
- `Shared.Models/Services/SelectQueryBuilder.cs` - QueryBuilder para proyecciones Select
- `Shared.Models/Requests/SearchRequest.cs` - Request para búsquedas
- `Shared.Models/QueryModels/QueryRequest.cs` - Request para queries dinámicas

## Flujo del Sistema

```
Frontend Component (.razor.cs)
    ↓
Frontend Service (BaseApiService)
    ↓ HTTP Request
Backend Controller (BaseQueryController)
    ↓
Backend Service (BaseQueryService)
    ↓ Entity Framework
Database
```

## Endpoints Disponibles

### CRUD Individual
- `POST /api/{entity}/create` - Crear entidad
- `PUT /api/{entity}/update` - Actualizar entidad
- `GET /api/{entity}/all?page=1&pageSize=10` - Obtener paginado
- `GET /api/{entity}/{id}` - Obtener por ID
- `DELETE /api/{entity}/{id}` - Eliminar por ID

### CRUD Batch
- `POST /api/{entity}/create-batch` - Crear múltiples
- `PUT /api/{entity}/update-batch` - Actualizar múltiples

### Query y Search
- `POST /api/{entity}/query` - Query dinámica
- `POST /api/{entity}/paged` - Query paginada
- `POST /api/{entity}/search` - Búsqueda inteligente
- `POST /api/{entity}/search-paged` - Búsqueda paginada
- `POST /api/{entity}/select` - Query con proyección
- `POST /api/{entity}/select-paged` - Query paginada con proyección

## Uso del QueryBuilder

### 1. Query Básica Fuertemente Tipada
```csharp
// En CategoriaService.cs
public async Task<List<Categoria>> BuscarActivasAsync()
{
    return await Query()
        .Where(c => c.Active == true)
        .OrderBy(c => c.FechaCreacion, true)
        .ToListAsync();
}
```

### 2. Query con Include (Relaciones)
```csharp
public async Task<List<Categoria>> BuscarConUsuarioAsync()
{
    return await Query()
        .Where(c => c.Active == true)
        .Include(c => c.Creador)
        .ToListAsync();
}
```

### 3. Búsqueda Inteligente con Campos Específicos
```csharp
public async Task<List<Categoria>> BuscarPorTextoAsync(string termino)
{
    return await Query()
        .Search(termino)
        .InFields(c => c.Nombre, c => c.Descripcion)
        .Where(c => c.Active == true)
        .ToListAsync();
}
```

### 4. Query con Select (Proyección)
```csharp
public async Task<List<CategoriaResumen>> BuscarResumenAsync(string termino)
{
    return await Query()
        .Where(c => c.Active == true)
        .Include(c => c.Creador)
        .Search(termino)
        .InFields(c => c.Nombre, c => c.Descripcion)
        .Select(c => new CategoriaResumen
        {
            Id = c.Id,
            Nombre = c.Nombre,
            CreadorNombre = c.Creador.Nombre,
            FechaCreacion = c.FechaCreacion
        })
        .ToListAsync();
}
```

### 5. Query Paginada
```csharp
public async Task<PagedResult<Categoria>> BuscarPaginadoAsync(int page, int size)
{
    return await Query()
        .Where(c => c.Active == true)
        .Skip((page - 1) * size)
        .Take(size)
        .ToPagedResultAsync();
}
```

## Integración con RadzenDataGrid

### 1. Uso Básico
```csharp
// En PagedCategorias.razor.cs
async Task LoadData(LoadDataArgs args)
{
    var response = await categoriaService.LoadDataAsync(args);
    
    if (response.Success)
    {
        grid.Data = response.Data.Data;
        grid.Count = response.Data.TotalCount;
    }
}
```

### 2. Con Campos de Búsqueda Específicos
```csharp
async Task LoadData(LoadDataArgs args)
{
    var response = await categoriaService.LoadDataAsync(
        args,
        c => c.Nombre, c => c.Descripcion  // Campos donde buscar
    );
    
    grid.Data = response.Data.Data;
    grid.Count = response.Data.TotalCount;
}
```

### 3. Con Filtro Base y Select
```csharp
async Task LoadData(LoadDataArgs args)
{
    var response = await categoriaService.LoadDataAsync(
        args,
        c => new { c.Id, c.Nombre, CreadorNombre = c.Creador.Nombre }, // Select
        Query().Where(c => c.Active == true).Include(c => c.Creador),  // Filtro base
        c => c.Nombre, c => c.Descripcion                              // Campos de búsqueda
    );
    
    grid.Data = response.Data.Data;
    grid.Count = response.Data.TotalCount;
}
```

### 4. Con Campos String (Anidados)
```csharp
async Task LoadData(LoadDataArgs args)
{
    var response = await categoriaService.LoadDataAsync(
        args,
        ["Nombre", "Descripcion", "Creador.Nombre"]  // Soporta campos anidados
    );
    
    grid.Data = response.Data.Data;
    grid.Count = response.Data.TotalCount;
}
```

## Búsqueda Inteligente

### Características
- **Strings**: Usa `Contains()` para búsqueda parcial
- **Números**: Convierte a string para búsqueda en folios/códigos
- **Fechas**: Búsqueda inteligente por formato de fecha
- **Múltiples campos**: Busca en todos los campos especificados

### Ejemplo Completo
```csharp
public async Task<List<Categoria>> BusquedaCompleta(string termino)
{
    return await Query()
        .Where(c => c.Active == true && c.Clave == "Soporte.2019")
        .Include(c => c.Creador)
        .Search(termino)
        .InFields(c => c.Nombre, c => c.Descripcion, c => c.Codigo)
        .OrderBy(c => c.FechaCreacion, true)
        .ToListAsync();
}
```

## Request Models

### SearchRequest
```csharp
public class SearchRequest
{
    public string SearchTerm { get; set; }
    public string[] SearchFields { get; set; }
    public QueryRequest? BaseQuery { get; set; }  // Query base para filtros adicionales
    public int? Skip { get; set; }
    public int? Take { get; set; }
}
```

### QueryRequest
```csharp
public class QueryRequest
{
    public string? Filter { get; set; }     // "Active == true && Name.Contains(\"test\")"
    public string? OrderBy { get; set; }    // "FechaCreacion desc"
    public string[]? Include { get; set; }  // ["Usuario", "Categoria"]
    public string? Select { get; set; }     // "new { Id, Nombre }"
    public int? Skip { get; set; }
    public int? Take { get; set; }
}
```

## Response Models

### PagedResult<T>
```csharp
public class PagedResult<T>
{
    public List<T> Data { get; set; }
    public int TotalCount { get; set; }
    public int Page { get; set; }
    public int PageSize { get; set; }
}
```

### ApiResponse<T>
```csharp
public class ApiResponse<T>
{
    public bool Success { get; set; }
    public T? Data { get; set; }
    public string Message { get; set; }
    public List<string>? Errors { get; set; }
}
```

## Conversión LoadDataArgs → Query

Los métodos `LoadDataAsync` convierten automáticamente:
- **args.Filter** → `.Search(termino)`
- **args.Filters** → `.Where()` conditions
- **args.Sorts** → `.OrderBy()`
- **args.Skip/Top** → `.Skip().Take()`

Esto permite usar **cualquier RadzenDataGrid** sin configuración adicional.

## Implementar en Nueva Entidad

### 1. Controller
```csharp
[Route("api/[controller]")]
public class MiEntidadController : BaseQueryController<MiEntidad>
{
    public MiEntidadController(BaseQueryService<MiEntidad> service, ILogger<MiEntidadController> logger)
        : base(service, logger)
    {
    }
}
```

### 2. Service Frontend
```csharp
public class MiEntidadService : BaseApiService<MiEntidad>
{
    public MiEntidadService(HttpClient httpClient, ILogger<MiEntidadService> logger)
        : base(httpClient, logger, "api/mientidad")
    {
    }
}
```

### 3. Usar en Component
```csharp
async Task LoadData(LoadDataArgs args)
{
    var response = await miEntidadService.LoadDataAsync(args);
    grid.Data = response.Data.Data;
    grid.Count = response.Data.TotalCount;
}
```

**¡Ya está listo para usar!** El sistema provee CRUD completo + Query + Search + integración Radzen automáticamente.