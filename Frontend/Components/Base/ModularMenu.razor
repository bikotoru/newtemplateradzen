@using Radzen.Blazor
@inject IJSRuntime JSRuntime

<div style="padding: 4px;">
    <!-- Buscador -->
    <div style="padding: 8px; margin-bottom: 8px;">
        <RadzenTextBox @bind-Value="searchTerm" 
                       @oninput="OnSearchChanged"
                       Placeholder="Buscar menús..." 
                       Style="width: 100%;"
                       aria-label="Buscar menús">
            <RadzenIcon Icon="search" Style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); pointer-events: none;" />
        </RadzenTextBox>
    </div>

    <!-- Módulos filtrados -->
    @if (filteredModules.Any())
    {
        @foreach (var module in filteredModules)
        {
            var moduleExpanded = expandedModules.ContainsKey(module.Text) ? expandedModules[module.Text] : false;
            
            <ModuleExpander Title="@module.Text" 
                           Icon="@module.Icon" 
                           IsExpanded="@moduleExpanded"
                           IsExpandedChanged="@((bool expanded) => OnModuleExpandedChanged(module.Text, expanded))">
                <RadzenPanelMenu>
                    @foreach (var item in GetFilteredMenuItems(module))
                    {
                        <RadzenPanelMenuItem Text="@item.Text" 
                                           Icon="@item.Icon" 
                                           Path="@item.Path" />
                    }
                </RadzenPanelMenu>
            </ModuleExpander>
        }
    }
    else if (!string.IsNullOrEmpty(searchTerm))
    {
        <div style="padding: 16px; text-align: center; color: var(--rz-text-disabled-color);">
            <RadzenIcon Icon="search_off" Style="font-size: 48px; margin-bottom: 8px;" />
            <div>No se encontraron resultados</div>
        </div>
    }
</div>

@code {
    [Parameter] public List<MenuModule> Modules { get; set; } = new();
    [Parameter] public List<string> UserPermissions { get; set; } = new();

    private string searchTerm = "";
    private List<MenuModule> filteredModules = new();
    private Dictionary<string, bool> expandedModules = new();

    protected override async Task OnInitializedAsync()
    {
        await JSRuntime.InvokeVoidAsync("console.log", "[ModularMenu] Inicializando con módulos:", Modules?.Count ?? 0);
        await JSRuntime.InvokeVoidAsync("console.log", "[ModularMenu] Permisos del usuario:", UserPermissions?.ToArray() ?? new string[0]);
        
        filteredModules = Modules.ToList();
        // Expandir el primer módulo por defecto
        if (Modules.Any())
        {
            expandedModules[Modules.First().Text] = true;
            await JSRuntime.InvokeVoidAsync("console.log", "[ModularMenu] Expandido por defecto:", Modules.First().Text);
        }
        
        await JSRuntime.InvokeVoidAsync("console.log", "[ModularMenu] Módulos filtrados iniciales:", filteredModules.Count);
    }

    private async Task OnSearchChanged(ChangeEventArgs args)
    {
        searchTerm = args.Value?.ToString() ?? "";
        await FilterModules();
        StateHasChanged();
    }

    private async Task FilterModules()
    {
        if (string.IsNullOrWhiteSpace(searchTerm))
        {
            filteredModules = Modules.ToList();
        }
        else
        {
            filteredModules = new List<MenuModule>();
            
            foreach (var module in Modules)
            {
                // Buscar en el nombre del módulo
                var moduleMatches = module.Text.Contains(searchTerm, StringComparison.OrdinalIgnoreCase);
                
                // Buscar en los items del módulo
                var matchingItems = module.MenuItems.Where(item => 
                    item.Text.Contains(searchTerm, StringComparison.OrdinalIgnoreCase) &&
                    HasPermission(item.Permissions)
                ).ToList();

                // Si el módulo o algún item coincide, incluir el módulo
                if (moduleMatches || matchingItems.Any())
                {
                    var filteredModule = new MenuModule
                    {
                        Text = module.Text,
                        Icon = module.Icon,
                        MenuItems = matchingItems.Any() ? matchingItems : 
                                   module.MenuItems.Where(item => HasPermission(item.Permissions)).ToList()
                    };
                    
                    filteredModules.Add(filteredModule);
                    
                    // Auto-expandir módulos que tienen coincidencias
                    if (matchingItems.Any())
                    {
                        expandedModules[module.Text] = true;
                    }
                }
            }
        }
    }

    private List<MenuItem> GetFilteredMenuItems(MenuModule module)
    {
        var filteredItems = new List<MenuItem>();
        
        foreach (var item in module.MenuItems)
        {
            var hasPermission = HasPermission(item.Permissions);
            JSRuntime.InvokeVoidAsync("console.log", $"[ModularMenu] Item '{item.Text}' con permisos {string.Join(",", item.Permissions)} -> Acceso: {hasPermission}");
            
            if (hasPermission)
            {
                filteredItems.Add(item);
            }
        }
        
        return filteredItems;
    }

    private bool HasPermission(List<string> requiredPermissions)
    {
        JSRuntime.InvokeVoidAsync("console.log", $"[ModularMenu] Verificando permisos requeridos: [{string.Join(",", requiredPermissions)}] contra usuario: [{string.Join(",", UserPermissions ?? new List<string>())}]");
        
        if (!requiredPermissions.Any()) 
        {
            JSRuntime.InvokeVoidAsync("console.log", "[ModularMenu] Sin permisos requeridos -> PERMITIDO");
            return true;
        }
        
        // Si tiene wildcard "*", permitir acceso a cualquiera
        if (requiredPermissions.Contains("*")) 
        {
            JSRuntime.InvokeVoidAsync("console.log", "[ModularMenu] Contiene wildcard '*' -> PERMITIDO");
            return true;
        }
        
        // Verificar permisos exactos
        foreach (var requiredPermission in requiredPermissions)
        {
            JSRuntime.InvokeVoidAsync("console.log", $"[ModularMenu] Verificando permiso: '{requiredPermission}'");
            
            // Permiso exacto
            if (UserPermissions?.Contains(requiredPermission) == true)
            {
                JSRuntime.InvokeVoidAsync("console.log", $"[ModularMenu] Permiso exacto encontrado: '{requiredPermission}' -> PERMITIDO");
                return true;
            }
                
            // Si el permiso requerido tiene wildcard (ej: "CATEGORIA.*")
            if (requiredPermission.EndsWith(".*"))
            {
                var basePermission = requiredPermission.Replace(".*", "");
                JSRuntime.InvokeVoidAsync("console.log", $"[ModularMenu] Verificando wildcard base: '{basePermission}'");
                
                // Verificar si el usuario tiene permisos específicos de ese módulo
                if (UserPermissions?.Any(up => up.StartsWith(basePermission + ".", StringComparison.OrdinalIgnoreCase)) == true)
                {
                    JSRuntime.InvokeVoidAsync("console.log", $"[ModularMenu] Permiso específico del módulo encontrado -> PERMITIDO");
                    return true;
                }
                // O si tiene el wildcard exacto
                if (UserPermissions?.Contains(requiredPermission) == true)
                {
                    JSRuntime.InvokeVoidAsync("console.log", $"[ModularMenu] Wildcard exacto encontrado -> PERMITIDO");
                    return true;
                }
            }
        }
        
        JSRuntime.InvokeVoidAsync("console.log", "[ModularMenu] Ningún permiso coincide -> DENEGADO");
        return false;
    }

    private async Task OnModuleExpandedChanged(string moduleText, bool expanded)
    {
        expandedModules[moduleText] = expanded;
        StateHasChanged();
    }
}